Triangle[27] addToArray(Triangle[27] to, int start, Triangle[3] from)
{
	for(int i = start, j = 0; j < 3 && i < 27; i++, j++)
	{
		to[i] = from[j];
	}
	return to;
}

float getTriangleSortValue(Triangle triangle)
{
	float max = triangle.verts[0].position.z;
	for(int i = 0; i < 3; i++)
	{
		if(max < triangle.verts[i].position.z)
			max = triangle.verts[i].position.z;
	}
	return max;

}
Triangle[27] selectionSort(Triangle[27] triangles)
{
	int minIndex = 0;
	for(int i = 0; i < 27; i++)
	{
		minIndex = i;
		for(int j = i+1; j < 27; j++)
		{
			if(getTriangleSortValue(triangles[i]) > getTriangleSortValue(triangles[minIndex]))
			{
				minIndex = j;
			}
		}
		// swap
		Triangle temp = triangles[minIndex];
		triangles[minIndex] = triangles[i];
		triangles[i] = temp;
	}

	return triangles;
}


void waterVersion1()
{
	int interval = 5;
	vec4 startPoint = gl_in[1].gl_Position;
	vec4 endPoint = gl_in[0].gl_Position;
	vec4 third = gl_in[2].gl_Position;
	vec4 color;


	for(int i = 0; i < interval; i++)
	{
		if(i % 2 == 0)
			color = vec4(0, 0, 1, 1);
		else
			color = vec4(0, 1, 0, 1);

		Triangle temp;
		temp.verts[0].color = color;
		temp.verts[0].position = (i/interval) * (startPoint + endPoint);

		temp.verts[1].color = color;
		temp.verts[1].position = ((i+1)/interval) * (startPoint + endPoint);

		temp.verts[2].color = color;
		temp.verts[2].position = third;

		geomIsTextured = 0;
		draw(temp);
	}	
}